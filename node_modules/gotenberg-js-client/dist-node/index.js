'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var http = _interopDefault(require('http'));
var https = _interopDefault(require('https'));
var url$1 = require('url');
var FormData = _interopDefault(require('form-data'));
var path$1 = require('path');
var fs = require('fs');
var stream = require('stream');

const parse = url => {
  const _url = new url$1.URL(url);

  const request = _url.protocol === 'http:' ? http.request : https.request;
  return [_url, request];
};

function post(url, data, headers) {
  const [_url, request] = parse(url);
  return new Promise((resolve, reject) => {
    const req = request(_url, {
      method: 'POST',
      ...this,
      headers: { ...data.getHeaders(),
        ...headers,
        ...(this ? this.headers : null)
      }
    });
    req.on('error', reject);
    req.on('response', res => {
      if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
        resolve(res);
      } else {
        let error = res.statusCode + ' ' + res.statusMessage;
        const chunks = [];
        res.on('data', chunk => chunks.push(chunk));
        res.on('end', () => {
          try {
            error += ' (' + JSON.parse(Buffer.concat(chunks).toString()).message + ')';
          } catch (err) {}

          reject(new Error(error));
        });
      }
    });
    data.pipe(req);
  });
}
function get(url) {
  const [_url, request] = parse(url);
  return new Promise((resolve, reject) => {
    const req = request(_url, {
      method: 'GET',
      ...this
    });
    req.on('error', reject);
    req.on('response', res => {
      if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
        resolve(res);
      } else {
        res.resume();
        reject(new Error(res.statusCode + ' ' + res.statusMessage));
      }
    });
    req.end();
  });
}
const client = config => ({
  post: post.bind(config || null),
  get: get.bind(config || null)
});

(function (RequestType) {
  RequestType[RequestType["Url"] = 0] = "Url";
  RequestType[RequestType["Ping"] = 1] = "Ping";
  RequestType[RequestType["Html"] = 2] = "Html";
  RequestType[RequestType["Merge"] = 3] = "Merge";
  RequestType[RequestType["Office"] = 4] = "Office";
  RequestType[RequestType["Markdown"] = 5] = "Markdown";
  RequestType[RequestType["Undefined"] = 6] = "Undefined";
})(exports.RequestType || (exports.RequestType = {}));

const gotenberg = (url, client$1, config) => {
  let instance;

  if (typeof client$1 === 'object' && 'post' in client$1) {
    instance = client$1;
  } else if (typeof client$1 === 'function') {
    if (/^class\s/.test(Function.prototype.toString.call(client$1))) {
      instance = new client$1(config);
    } else {
      instance = client$1(config);
    }
  } else {
    instance = client(config || client$1);
  }

  return source => ({
    type: exports.RequestType.Undefined,
    url: url.toString(),
    client: instance,
    source,
    fields: {}
  });
};

const isString = x => typeof x === 'string';
const isBuffer = x => x != null && x instanceof Buffer;
const isStream = x => x != null && x instanceof stream.Readable;
const isURL = x => x != null && x instanceof url$1.URL;
const isFileUri = x => isString(x) && x.startsWith('file:');
const isPlain = x => isString(x) || isStream(x) || isBuffer(x);
const isTuple = x => Array.isArray(x) && x.length === 2 && typeof x[0] === 'string' && isPlain(x[1]);
const isObject = x => {
  if (x == null || typeof x !== 'object' || Array.isArray(x) || typeof x[Symbol.iterator] === 'function' || x instanceof url$1.URL) {
    return false;
  }

  for (const key in x) {
    if (x.hasOwnProperty(key) && !isPlain(x[key])) return false;
  }

  return true;
};
const isIterable = x => {
  if (x == null || typeof x === 'string') return false;

  if (typeof x[Symbol.iterator] === 'function') {
    for (const src of x) {
      if (src == null) return false;
      if (!isPlain(src) && !isTuple(src) && !isObject(src)) return false;
    }

    return true;
  }

  return false;
};
const filenameRE = /.+\..+/;
const filenameReservedRE = /[<>:"/\\|?*\u0000-\u001F]/g;
const windowsReservedNameRE = /^(con|prn|aux|nul|com\d|lpt\d)$/i;
const MAX_FILE_NAME_LENGTH = 255;
const isFileName = x => isString(x) && x.length <= MAX_FILE_NAME_LENGTH && x !== '.' && x !== '..' && !x.startsWith('file:') && !filenameReservedRE.test(x) && !windowsReservedNameRE.test(x) && filenameRE.test(x);

const DEFAULT_FILENAME = 'index.html';
const toTuples = (source, recursive = false) => {
  if (isURL(source)) return [];

  if (isFileUri(source)) {
    return !recursive && path$1.extname(source) === '.html' ? [[DEFAULT_FILENAME, source]] : [[path$1.basename(source), source]];
  }

  if (isString(source) || isBuffer(source)) {
    return [[DEFAULT_FILENAME, source]];
  }

  if (isStream(source)) {
    if (source instanceof fs.ReadStream) {
      const name = path$1.basename(String(source.path));
      return !recursive && path$1.extname(name) === '.html' ? [[DEFAULT_FILENAME, source]] : [[name, source]];
    } else {
      return [[DEFAULT_FILENAME, source]];
    }
  }

  if (isTuple(source)) {
    if (isFileName(source[0])) {
      return [source];
    }

    throw new Error(`Source name "${source[0]}" doesn't look like file name`);
  }

  if (isObject(source)) {
    const ret = [];

    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (isFileName(key)) {
          ret.push([key, source[key]]);
        } else {
          throw new Error(`Source name "${key}" doesn't look like file name`);
        }
      }
    }

    return ret;
  }

  if (isIterable(source)) {
    const ret = [];

    for (const src of source) {
      ret.push(...toTuples(src, true));
    }

    return ret;
  }

  throw new Error(`Bad source, don't know what to do with "${source}"`);
};
const fromFile = path => fs.createReadStream(path.replace(/^file:(\/\/)?/, ''));
const toStream = source => isStream(source) ? source : isFileUri(source) ? fromFile(source) : new stream.Readable({
  read() {
    this.push(source);
    this.push(null);
  }

});
const toStreams = source => {
  if (!source) return [];
  const tuples = toTuples(source);
  const ret = [];

  for (let i = 0; i < tuples.length; i++) {
    ret.push([tuples[i][0], toStream(tuples[i][1])]);
  }

  return ret;
};

const formdata = (fields, files) => {
  const data = new FormData();

  for (const field in fields) {
    if (fields.hasOwnProperty(field)) {
      const value = fields[field];

      if (value !== undefined) {
        data.append(field, String(value));
      }
    }
  }

  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    data.append(file[0], file[1], {
      filename: file[0]
    });
  }

  return data;
};

const validateSources = (type, sources) => {
  const filenames = sources.map(source => source[0]);
  const duplicates = filenames.filter((name, index, arr) => arr.indexOf(name) !== index);

  if (duplicates.length > 0) {
    throw new Error(`There are duplicates in file names: ${duplicates.join(',')}`);
  }

  const hasDefault = filenames.includes(DEFAULT_FILENAME);

  if ((type === exports.RequestType.Html || type === exports.RequestType.Markdown) && !hasDefault) {
    throw new Error(`File "${DEFAULT_FILENAME}" is required for ${type === exports.RequestType.Html ? 'HTML' : 'Markdown'} conversion`);
  }

  if (type === exports.RequestType.Office && hasDefault) {
    throw new Error(`Default filename "${DEFAULT_FILENAME}" is not allowed for Office conversion, ` + `looks like you didn't set filename for document`);
  }

  return sources;
};

const please = request => {
  if (request.type === exports.RequestType.Ping) {
    if (typeof request.client.get === 'function') {
      return request.client.get(request.url).then(response => {
        response.resume();
      });
    }

    throw new Error(`Gotenberg client doesn't implements "get" method`);
  }

  const sources = validateSources(request.type, toStreams(request.source));
  const form = formdata(request.fields, sources);
  return request.client.post(request.url, form, request.headers);
};

const pipe = (...fns) => source => fns.reduce((request, fn) => fn(request), source);

const fields = fields => request => ({ ...request,
  fields: { ...request.fields,
    ...fields
  }
});

const path = path => request => ({ ...request,
  url: (request.url || '') + path
});

const type = type => request => {
  if ('type' in request && request.type !== exports.RequestType.Undefined) {
    throw new Error(`Cannot set "${exports.RequestType[type]}" conversion, already set to "${exports.RequestType[request.type]}"`);
  }

  return { ...request,
    type
  };
};

const markdown = x => 'type' in x ? pipe(path('/markdown'), type(exports.RequestType.Markdown))(x) : pipe(fields(x), path('/markdown'), type(exports.RequestType.Markdown));

const convert = path('/convert');

const office = pipe(path('/office'), type(exports.RequestType.Office));

const merge = request => {
  if (!isIterable(request.source) && !isObject(request.source)) {
    throw new Error('Invalid source, should be iterable or object');
  }

  return pipe(path('/merge'), type(exports.RequestType.Merge))(request);
};

const ping = pipe(path('/ping'), type(exports.RequestType.Ping));

const html = x => 'type' in x ? pipe(path('/html'), type(exports.RequestType.Html))(x) : pipe(fields(x), path('/html'), type(exports.RequestType.Html));

const url = request => {
  if (!isString(request.source) && !isURL(request.source)) {
    throw new Error('Invalid source, should be url string or instance of URL');
  }

  return pipe(fields({
    remoteURL: request.source.toString(),
    marginTop: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0
  }), path('/url'), type(exports.RequestType.Url))({ ...request,
    source: undefined
  });
};

const merge$1 = (request, modify) => {
  const result = { ...request,
    ...modify
  };

  for (const key in modify) {
    if (modify[key] && request[key] && typeof modify[key] === 'object' && typeof request[key] === 'object') {
      result[key] = merge$1(request[key], modify[key]);
    }
  }

  return result;
};

const adjust = modify => request => merge$1(request, modify);

const headers = headers => request => ({ ...request,
  headers: { ...request.headers,
    ...headers
  }
});

const add = (...opts) => {
  const httpHeaders = {};

  for (let i = opts.length; i--;) {
    const op = opts[i];
    op(httpHeaders);
  }

  return headers(httpHeaders);
};

const set = (...opts) => {
  const options = {};

  for (let i = opts.length; i--;) {
    const op = opts[i];

    if (typeof op === 'function') {
      op(options);
    } else {
      Object.assign(options, op);
    }
  }

  return fields(options);
};

const setProperty = (...fields) => (...values) => object => {
  for (let i = 0; i < fields.length; i++) {
    object[fields[i]] = values[i];
  }
};

const A3 = [11.7, 16.5];
const A4 = [8.27, 11.7];
const A5 = [5.8, 8.3];
const A6 = [4.1, 5.8];
const LETTER = [8.5, 11];
const LEGAL = [8.5, 14];
const TABLOID = [11, 17];
const NO_MARGINS = [0, 0, 0, 0];
const NORMAL_MARGINS = [1, 1, 1, 1];
const LARGE_MARGINS = [2, 2, 2, 2];

const landscape = setProperty('landscape')(true);
const portrait = setProperty('landscape')();
const paperSize = paper => Array.isArray(paper) ? setProperty('paperWidth', 'paperHeight')(...paper) : setProperty('paperWidth', 'paperHeight')(paper.width, paper.height);
const a3 = paperSize(A3);
const a4 = paperSize(A4);
const a5 = paperSize(A5);
const a6 = paperSize(A6);
const legal = paperSize(LEGAL);
const letter = paperSize(LETTER);
const tabloid = paperSize(TABLOID);
const marginSizes = margins => Array.isArray(margins) ? setProperty('marginTop', 'marginRight', 'marginBottom', 'marginLeft')(...margins) : setProperty('marginTop', 'marginRight', 'marginBottom', 'marginLeft')(margins.top, margins.right, margins.bottom, margins.left);
const noMargins = marginSizes(NO_MARGINS);
const normalMargins = marginSizes(NORMAL_MARGINS);
const largeMargins = marginSizes(LARGE_MARGINS);

const to = (...opts) => {
  const options = {};
  let paper;
  let margins;

  for (let i = opts.length; i--;) {
    const op = opts[i];

    if (typeof op === 'function') {
      op(options);
      continue;
    }

    if (Array.isArray(op)) {
      if (op.length === 2) paper = op;
      if (op.length === 4) margins = op;
      continue;
    }

    if ('width' in op || 'height' in op) {
      paper = op;
      continue;
    }

    if ('top' in op || 'right' in op || 'bottom' in op || 'left' in op) {
      margins = op;
      continue;
    }

    if ('paper' in op && op.paper) {
      paper = op.paper;
      op.paper = undefined;
    }

    if ('margins' in op && op.margins) {
      margins = op.margins;
      op.margins = undefined;
    }

    Object.assign(options, op);
  }

  paper && paperSize(paper)(options);
  margins && marginSizes(margins)(options);
  return fields(options);
};

const header = (name, value) => setProperty(`Gotenberg-Remoteurl-${name}`)(value);
const headers$1 = headers => _ => {
  for (const name in headers) {
    header(name, headers[name])(_);
  }
};
const webhookHeader = (name, value) => setProperty(`Gotenberg-Webhookurl-${name}`)(value);
const webhookHeaders = headers => _ => {
  for (const name in headers) {
    webhookHeader(name, headers[name])(_);
  }
};

const filename = setProperty('resultFilename');
const timeout = setProperty('waitTimeout');
const delay = setProperty('waitDelay');
const webhook = setProperty('webhookURL', 'webhookURLTimeout');
const googleChromeRpccBufferSize = setProperty('googleChromeRpccBufferSize');
const range = setProperty('pageRanges');
const scale = setProperty('scale');

exports.A3 = A3;
exports.A4 = A4;
exports.A5 = A5;
exports.A6 = A6;
exports.LARGE_MARGINS = LARGE_MARGINS;
exports.LEGAL = LEGAL;
exports.LETTER = LETTER;
exports.NORMAL_MARGINS = NORMAL_MARGINS;
exports.NO_MARGINS = NO_MARGINS;
exports.TABLOID = TABLOID;
exports.a3 = a3;
exports.a4 = a4;
exports.a5 = a5;
exports.a6 = a6;
exports.add = add;
exports.adjust = adjust;
exports.convert = convert;
exports.delay = delay;
exports.filename = filename;
exports.googleChromeRpccBufferSize = googleChromeRpccBufferSize;
exports.gotenberg = gotenberg;
exports.header = header;
exports.headers = headers$1;
exports.html = html;
exports.landscape = landscape;
exports.largeMargins = largeMargins;
exports.legal = legal;
exports.letter = letter;
exports.marginSizes = marginSizes;
exports.markdown = markdown;
exports.merge = merge;
exports.noMargins = noMargins;
exports.normalMargins = normalMargins;
exports.office = office;
exports.paperSize = paperSize;
exports.ping = ping;
exports.pipe = pipe;
exports.please = please;
exports.portrait = portrait;
exports.range = range;
exports.scale = scale;
exports.set = set;
exports.tabloid = tabloid;
exports.timeout = timeout;
exports.to = to;
exports.url = url;
exports.webhook = webhook;
exports.webhookHeader = webhookHeader;
exports.webhookHeaders = webhookHeaders;
//# sourceMappingURL=index.js.map
